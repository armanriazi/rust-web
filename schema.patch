diff --git a/Cargo.lock b/Cargo.lock
index 947537e..adc4fe6 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1,15 +1,15 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
 version = 3
 
 [[package]]
 name = "anyhow"
-version = "1.0.68"
+version = "1.0.69"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2cb2f989d18dd141ab8ae82f64d1a8cdd37e0840f73a406896cf5e99502fab61"
+checksum = "224afbd727c3d6e4b90103ece64b8d1b67fbb1973b1046c2281eed3f3803f800"
 
 [[package]]
 name = "autocfg"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
@@ -56,15 +56,15 @@ dependencies = [
  "quote",
  "syn",
 ]
 
 [[package]]
 name = "diesel"
-version = "2.0.2"
+version = "2.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "68c186a7418a2aac330bb76cde82f16c36b03a66fb91db32d20214311f9f6545"
+checksum = "4391a22b19c916e50bec4d6140f29bdda3e3bb187223fe6e3ea0b6e4d1021c04"
 dependencies = [
  "diesel_derives",
  "libsqlite3-sys",
 ]
 
 [[package]]
@@ -82,12 +82,18 @@ dependencies = [
 [[package]]
 name = "diff"
 version = "0.1.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8"
 
+[[package]]
+name = "dotenv"
+version = "0.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77c90badedccf4105eca100756a0b1289e191f6fcbdadd3cee1d2f614f97da8f"
+
 [[package]]
 name = "dotenvy"
 version = "0.15.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "03d8c417d7a8cb362e0c37e5d815f5eb7c37f79ff93707329d5a194e42e54ca0"
 
@@ -141,12 +147,18 @@ checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
 [[package]]
 name = "libc"
 version = "0.2.139"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79"
 
+[[package]]
+name = "libm"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "348108ab3fba42ec82ff6e9564fc4ca0247bdccdc68dd8af9764bbc79c3c8ffb"
+
 [[package]]
 name = "libsqlite3-sys"
 version = "0.25.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "29f835d03d717946d28b1d1ed632eb6f0e24a299388ee623d0c23118d3e8a7fa"
 dependencies = [
@@ -158,12 +170,13 @@ dependencies = [
 name = "num-traits"
 version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
 dependencies = [
  "autocfg",
+ "libm",
 ]
 
 [[package]]
 name = "output_vt100"
 version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -219,24 +232,24 @@ dependencies = [
  "quote",
  "version_check",
 ]
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.50"
+version = "1.0.51"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6ef7d57beacfaf2d8aee5937dab7b7f28de3cb8b1828479bb5de2a7106f2bae2"
+checksum = "5d727cae5b39d21da60fa540906919ad737832fe0b1c165da3a34d6548c849d6"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "proptest"
-version = "1.0.0"
+version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e0d9cc07f18492d879586c92b485def06bc850da3118075cd45d50e9c95b0e5"
+checksum = "29f1b898011ce9595050a68e60f90bad083ff2987a695a42357134c8381fba70"
 dependencies = [
  "bit-set",
  "bitflags",
  "byteorder",
  "lazy_static",
  "num-traits",
@@ -244,12 +257,13 @@ dependencies = [
  "rand",
  "rand_chacha",
  "rand_xorshift",
  "regex-syntax",
  "rusty-fork",
  "tempfile",
+ "unarray",
 ]
 
 [[package]]
 name = "quick-error"
 version = "1.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -374,29 +388,24 @@ dependencies = [
  "quote",
  "syn",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.91"
+version = "1.0.92"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883"
+checksum = "7434af0dc1cbd59268aa98b4c22c131c0584d2232f6fb166efb993e2832e896a"
 dependencies = [
  "itoa",
  "ryu",
  "serde",
 ]
 
 [[package]]
 name = "shared"
 version = "0.1.0"
-dependencies = [
- "diesel",
- "dotenvy",
- "serde",
-]
 
 [[package]]
 name = "syn"
 version = "1.0.107"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5"
@@ -417,12 +426,18 @@ dependencies = [
  "libc",
  "redox_syscall",
  "remove_dir_all",
  "winapi",
 ]
 
+[[package]]
+name = "unarray"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eaea85b334db583fe3274d12b4cd1880032beab409c0d774be044d4480ab9a94"
+
 [[package]]
 name = "unicode-ident"
 version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc"
 
@@ -467,13 +482,13 @@ dependencies = [
 [[package]]
 name = "web_edu_lib"
 version = "0.1.0"
 dependencies = [
  "anyhow",
  "diesel",
- "dotenvy",
+ "dotenv",
  "pretty_assertions",
  "proptest",
  "serde",
  "serde_json",
  "shared",
 ]
diff --git a/workspace/shared/Cargo.toml b/workspace/shared/Cargo.toml
index 0c70dcd..72480d8 100644
--- a/workspace/shared/Cargo.toml
+++ b/workspace/shared/Cargo.toml
@@ -3,10 +3,6 @@ name = "shared"
 version = "0.1.0"
 authors = ["Arman Riazi"]
 edition = "2021"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
-[dependencies]
-diesel = { version = "2.0.0", features = ["sqlite"] }
-dotenvy = "0.15"
-serde = { version = "1.0", features = ["derive"], optional = true , default-features = true}
\ No newline at end of file
diff --git a/workspace/shared/src/core/connection.rs b/workspace/shared/src/core/connection.rs
deleted file mode 100644
index 9ef3c67..0000000
--- a/workspace/shared/src/core/connection.rs
+++ /dev/null
@@ -1,102 +0,0 @@
-
-
- #[macro_use]
-        extern crate diesel;
-        extern crate dotenv;
-        extern crate serde;
-        extern crate serde_json;
-//#[cfg(feature = "establish_connection")]
-pub mod establish_connection {
-
-        use diesel::prelude::*;
-        use diesel::sqlite::SqliteConnection;
-        // use diesel::mysql::MysqlConnection;
-        //use diesel::pg::PgConnection;
-        use dotenv::dotenv;
-        use std::env;
-
-    pub fn establish_connection() -> SqliteConnection {
-        dotenv().ok();
-
-        let database_url = env::var("DATABASE_URL")
-            .expect("DATABASE_URL must be set");
-        SqliteConnection::establish(&database_url)
-            .expect(&format!("Error connecting to {}", database_url))
-    }
-
-    pub fn establish_connection_test() -> SqliteConnection {
-        dotenv().ok();
-
-        let database_url = env::var("TEST_DATABASE_URL")
-            .expect("DATABASE_URL must be set");
-        SqliteConnection::establish(&database_url)
-            .expect(&format!("Error connecting to {}", database_url))
-    }
-}
-/*
-#[macro_use]
-extern crate diesel;
-extern crate dotenv;
-extern crate serde;
-extern crate serde_json;
-
-pub mod schema;
-pub mod models;
-
-use diesel::prelude::*;
-use diesel::pg::PgConnection;
-use dotenv::dotenv;
-use std::env;
-
-pub fn establish_connection() -> PgConnection {
-    dotenv().ok();
-
-    let database_url = env::var("DATABASE_URL")
-        .expect("DATABASE_URL must be set");
-    PgConnection::establish(&database_url)
-        .expect(&format!("Error connecting to {}", database_url))
-}
-
-pub fn establish_connection_test() -> PgConnection {
-    dotenv().ok();
-
-    let database_url = env::var("TEST_DATABASE_URL")
-        .expect("DATABASE_URL must be set");
-    PgConnection::establish(&database_url)
-        .expect(&format!("Error connecting to {}", database_url))
-}
-*/
-
-/*
-#[macro_use]
-extern crate diesel;
-extern crate dotenv;
-extern crate serde;
-extern crate serde_json;
-
-pub mod schema;
-pub mod models;
-
-use diesel::prelude::*;
-use diesel::mysql::MysqlConnection;
-use dotenv::dotenv;
-use std::env;
-
-pub fn establish_connection() -> MysqlConnection {
-    dotenv().ok();
-
-    let database_url = env::var("DATABASE_URL")
-        .expect("DATABASE_URL must be set");
-    MysqlConnection::establish(&database_url)
-        .expect(&format!("Error connecting to {}", database_url))
-}
-
-pub fn establish_connection_test() -> MysqlConnection {
-    dotenv().ok();
-
-    let database_url = env::var("TEST_DATABASE_URL")
-        .expect("DATABASE_URL must be set");
-    MysqlConnection::establish(&database_url)
-        .expect(&format!("Error connecting to {}", database_url))
-}
-*/
\ No newline at end of file
diff --git a/workspace/shared/src/core/mod.rs b/workspace/shared/src/core/mod.rs
index b3b606b..420a3d9 100644
--- a/workspace/shared/src/core/mod.rs
+++ b/workspace/shared/src/core/mod.rs
@@ -1 +1 @@
-pub mod connection;
+pub mod vacancy;
diff --git a/workspace/web_edu/web_edu_lib/Cargo.toml b/workspace/web_edu/web_edu_lib/Cargo.toml
index 5d907f3..fa7ae4b 100644
--- a/workspace/web_edu/web_edu_lib/Cargo.toml
+++ b/workspace/web_edu/web_edu_lib/Cargo.toml
@@ -5,21 +5,21 @@ authors = ["Arman Riazi"]
 edition = "2021"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
 diesel = { version = "2.0.0", features = ["sqlite"] }
-dotenvy = "0.15"
-shared = { path = "../../shared",  optional = false , default-features = true}
-serde = { version = "1.0", features = ["derive"], optional = true , default-features = true}
+dotenv = "0.15"
+serde = { version = "1.0.152", features = ["derive"]}
 serde_json="1.0.0"
+shared = { path = "../../shared",  optional = false , default-features = true}
 anyhow="1.0.68"
 
 [dev-dependencies]
-proptest = "1"
-pretty_assertions = "1"
+proptest = "1.0.0"
+pretty_assertions = "1.0.0"
 
 [[test]]
 doc = true
 name = "integration_dep_test"
 path = "test/integration_dep_test.rs"
 test = true
\ No newline at end of file
diff --git a/workspace/web_edu/web_edu_lib/src/core/mod.rs b/workspace/web_edu/web_edu_lib/src/core/mod.rs
index 015d915..90700fe 100644
--- a/workspace/web_edu/web_edu_lib/src/core/mod.rs
+++ b/workspace/web_edu/web_edu_lib/src/core/mod.rs
@@ -1,2 +1,5 @@
+
+
+pub mod connection;
 pub mod product;
-pub mod product_variant;
\ No newline at end of file
+pub mod product_variant;
diff --git a/workspace/web_edu/web_edu_lib/src/core/product.rs b/workspace/web_edu/web_edu_lib/src/core/product.rs
index 3015df3..a18bb8e 100644
--- a/workspace/web_edu/web_edu_lib/src/core/product.rs
+++ b/workspace/web_edu/web_edu_lib/src/core/product.rs
@@ -1,19 +1,43 @@
 
 
 pub mod create_product{
-    use ::web_edu::models::NewProduct;
+    use crate::model::model::model_product::NewProduct;
     use diesel::sqlite::SqliteConnection;
     use diesel::result::Error;
     use diesel::RunQueryDsl;
     //use shared::core::connection::establish_connection;
 
 
     /// The insert_into function needs a target. In this case, the target is products, which comes from the DSL module from the products schema. We can use the values method to insert the data. It can be a single value or several. For our use case, we need a single product that will be used in the future endpoint.
     /// This function will return the number of rows inserted if it is successful. Otherwise, it will return an error.
-    fn create_product(new_product: NewProduct, conn: &SqliteConnection) -> Result<usize, Error>  {
-        use ::web_edu::schema::products::dsl::*;
+    pub fn create_product(new_product: NewProduct, conn: & mut SqliteConnection) -> Result<usize, Error>  {
+        use crate::schema::products::dsl::*;
         diesel::insert_into(products)
             .values(new_product)
             .execute(conn)
     }
+}
+
+
+#[cfg(test)]
+mod tests {
+use diesel::{Connection, result::Error};
+use crate::{core::{connection::connection::establish_connection_test, product::create_product::create_product}, model::model::model_product::NewProduct};
+///  function called test_transaction, which is very useful because it doesn’t commit to the database. This allows us to have a clean database every time we run our tests.
+#[test]
+fn create_product_test() {
+    let mut conn = establish_connection_test();
+    conn.test_transaction::<_, Error, _>(|conn| {
+          let results = 
+            create_product(NewProduct {
+                name: "boots".to_string(),
+                cost: 13.23,
+                active: true
+            }, conn);
+     assert_eq!(Ok(1), results);
+    //let all_names = products.select(name).load::<String>(conn)?;
+    //assert_eq!(vec!["Sean", "Tess", "Ruby"], all_names);
+    Ok(())
+});
+}
 }
\ No newline at end of file
diff --git a/workspace/web_edu/web_edu_lib/src/core/product_variant.rs b/workspace/web_edu/web_edu_lib/src/core/product_variant.rs
index 9ea9865..4e2b52f 100644
--- a/workspace/web_edu/web_edu_lib/src/core/product_variant.rs
+++ b/workspace/web_edu/web_edu_lib/src/core/product_variant.rs
@@ -1,146 +1,145 @@
 
 pub mod create_product{
-
-    #[macro_use]
-    extern crate diesel;
-
-    use anyhow::Result;
-    use diesel::sqlite::SqliteConnection;
-    use diesel::ExpressionMethods;
-    use ::web_edu_model_product::models::*;//web_edu_model_variant
-    use diesel::Connection;
-    use diesel::RunQueryDsl;
-    use diesel::query_dsl::QueryDsl;
-
-    /// we use the macro no_arg_sql_function!, which allows us to use an SQL function in our code. 
-    /// In this case, SQLite does not have RETURNING for our inserts implemented.
-    /// Therefore, we need a function called last_insert_rowid to get the last id inserted.
-    // Note: We must be careful to use this function in a transaction.
-    no_arg_sql_function!(last_insert_rowid, diesel::sql_types::Integer);
-
-    fn create_product(new_product: NewCompleteProduct, conn: &SqliteConnection) -> Result<i32>  {
-        use ::web_edu::schema::products::dsl::products;
-        use ::web_edu::schema::variants::dsl::*;
-        use ::web_edu::schema::products_variants::dsl::*;
-
-        conn.transaction(|| {
-            diesel::insert_into(products)
-                .values(new_product.product)
-                .execute(conn)?;
-
-            let last_product_id: i32 = diesel::select(last_insert_rowid).first(conn)?;
-
-            // In the code, we make a loop over the new variants and filter them by name to check if the variant was already created. 
-            // We do this to avoid duplications and create it if necessary.
-            for new_variant in new_product.variants {
-                let variants_result =
-                    variants
-                        .filter(name.eq(&new_variant.variant.name))
-                        .limit(1)
-                        .load::<Variant>(conn)?;
-
-                let last_variant_id: i32 =
-                    match variants_result.first() {
-                        Some(variant) => variant.id,
-                        None => {
-                            diesel::insert_into(variants)
-                                .values(name.eq(&new_variant.variant.name))
-                                .execute(conn)?;
-
-                            diesel::select(last_insert_rowid).first(conn)?
-                        }
-                    };
-
-                // Finally, we create the relationships needed for the products and variants.
-                for new_value in new_variant.values {
-                    diesel::insert_into(products_variants)
-                        .values(
-                            (
-                                product_id.eq(last_product_id), 
-                                variant_id.eq(last_variant_id),
-                                value.eq(new_value), 
-                            )
-                        )
-                        .execute(conn)?;
-                }
-            }
-            Ok(last_product_id)
-        })
-    }
-    
-}
-
-
-// impl<T: Display> Display for Complex<T> {
-//     fn fmt(&self, f: &mut Formatter) -> Result {
-//         write!(f, "{} + {}i", self., self.)
+//     use anyhow::Result;
+//     use diesel::sqlite::SqliteConnection;
+//     use diesel::ExpressionMethods;
+//     use diesel::Connection;
+//     use diesel::RunQueryDsl;
+//     use diesel::query_dsl::QueryDsl;
+//     use crate::model::model::NewCompleteProduct;
+//     use crate::model::model::model_product;
+//     use crate::model::model::model_variant::Variant;
+//     use crate::schema; //web_edu_model_variant
+
+//     /// we use the macro no_arg_sql_function!, which allows us to use an SQL function in our code. 
+//     /// In this case, SQLite does not have RETURNING for our inserts implemented.
+//     /// Therefore, we need a function called last_insert_rowid to get the last id inserted.
+//     // Note: We must be careful to use this function in a transaction.
+//     no_arg_sql_function!(last_insert_rowid, diesel::sql_types::Integer);
+
+//     fn create_product(new_product: NewCompleteProduct, conn: &mut SqliteConnection) -> Result<i32>  {
+//         use schema::products::dsl::products;
+//         use schema::variants::dsl::*;
+//         use schema::products_variants::dsl::*;
+
+//         conn.transaction(|| {
+//             diesel::insert_into(products)
+//                 .values(new_product.product)
+//                 .execute(conn)?;
+
+//             let last_product_id: i32 = diesel::select(last_insert_rowid).first(conn)?;
+
+//             // In the code, we make a loop over the new variants and filter them by name to check if the variant was already created. 
+//             // We do this to avoid duplications and create it if necessary.
+//             for new_variant in new_product.variants {
+//                 let variants_result =
+//                     variants
+//                         .filter(name.eq(&new_variant.variant.name))
+//                         .limit(1)
+//                         .load::<Variant>(conn)?;
+
+//                 let last_variant_id: i32 =
+//                     match variants_result.first() {
+//                         Some(variant) => variant.id,
+//                         None => {
+//                             diesel::insert_into(variants)
+//                                 .values(name.eq(&new_variant.variant.name))
+//                                 .execute(conn)?;
+
+//                             diesel::select(last_insert_rowid).first(conn)?
+//                         }
+//                     };
+
+//                 // Finally, we create the relationships needed for the products and variants.
+//                 for new_value in new_variant.values {
+//                     diesel::insert_into(products_variants)
+//                         .values(
+//                             (
+//                                 product_id.eq(last_product_id), 
+//                                 variant_id.eq(last_variant_id),
+//                                 value.eq(new_value), 
+//                             )
+//                         )
+//                         .execute(conn)?;
+//                 }
+//             }
+//             Ok(last_product_id)
+//         })
 //     }
+    
 // }
-#[cfg(test)]
-mod tests {
-use super::*;
-use ::shared::connection::establish_connection_test;
-use diesel::result::Error;
-
-#[test]
-fn create_product_test() {
-    let connection = establish_connection_test();
-    connection.test_transaction::<_, Error, _>(|| {
-        create_product(NewCompleteProduct {
-            product: NewProduct {
-                name: "boots".to_string(),
-                cost: 13.23,
-                active: true
-            },
-            variants: vec![
-                NewVariantValue {
-                    variant: NewVariant {
-                        name: "size".to_string()
-                    },
-                    values: vec![
-                        Some(12.to_string()),
-                        Some(14.to_string()),
-                        Some(16.to_string()),
-                        Some(18.to_string())
-                    ]
-                }
-            ]
-        }, &connection).unwrap();
 
-        // The function list_products is created to list the last products with their variants.
-        assert_eq!(
-            serde_json::to_string(&list_products(&connection).unwrap()).unwrap(),
-            serde_json::to_string(&vec![
-                (
-                    Product {
-                        id: 1,
-                        name: "boots".to_string(),
-                        cost: 13.23,
-                        active: true
-                    },
-                    vec![
-                        (
-                            Some(12.to_string()),
-                            "size".to_string()
-                        ),
-                        (
-                            Some(14.to_string()),
-                            "size".to_string()
-                        ),
-                        (
-                            Some(16.to_string()),
-                            "size".to_string()
-                        ),
-                        (
-                            Some(18.to_string()),
-                            "size".to_string()
-                        )
-                    ]
-                ),
-            ]).unwrap()
-        );
 
-        Ok(())
-    });
-  }
+// // impl<T: Display> Display for Complex<T> {
+// //     fn fmt(&self, f: &mut Formatter) -> Result {
+// //         write!(f, "{} + {}i", self., self.)
+// //     }
+// // }
+// #[cfg(test)]
+// mod tests {
+// use super::*;
+// use crate::{core::connection::connection::establish_connection_test, model::model::{NewVariantValue, model_variant::NewVariant, NewCompleteProduct, model_product::{NewProduct, Product}}};
+// use diesel::result::Error;
+
+// #[test]
+// fn create_product_test() {
+//     let mut conn = establish_connection_test();
+//     conn.test_transaction::<_, Error, _>(|conn| {
+//         create_product(NewCompleteProduct {
+//             product: NewProduct {
+//                 name: "boots".to_string(),
+//                 cost: 13.23,
+//                 active: true
+//             },
+//             variants: vec![
+//                 NewVariantValue {
+//                     variant: NewVariant {
+//                         name: "size".to_string()
+//                     },
+//                     values: vec![
+//                         Some(12.to_string()),
+//                         Some(14.to_string()),
+//                         Some(16.to_string()),
+//                         Some(18.to_string())
+//                     ]
+//                 }
+//             ]
+//         }, &conn).unwrap();
+
+//         // The function list_products is created to list the last products with their variants.
+//         assert_eq!(
+//             serde_json::to_string(&list_products(&conn).unwrap()).unwrap(),
+//             serde_json::to_string(&vec![
+//                 (
+//                     Product {
+//                         id: 1,
+//                         name: "boots".to_string(),
+//                         cost: 13.23,
+//                         active: true
+//                     },
+//                     vec![
+//                         (
+//                             Some(12.to_string()),
+//                             "size".to_string()
+//                         ),
+//                         (
+//                             Some(14.to_string()),
+//                             "size".to_string()
+//                         ),
+//                         (
+//                             Some(16.to_string()),
+//                             "size".to_string()
+//                         ),
+//                         (
+//                             Some(18.to_string()),
+//                             "size".to_string()
+//                         )
+//                     ]
+//                 ),
+//             ]).unwrap()
+//         );
+
+//         Ok(())
+//     });
+//   }
 }
\ No newline at end of file
diff --git a/workspace/web_edu/web_edu_lib/src/lib.rs b/workspace/web_edu/web_edu_lib/src/lib.rs
index 897a518..3d47ca9 100644
--- a/workspace/web_edu/web_edu_lib/src/lib.rs
+++ b/workspace/web_edu/web_edu_lib/src/lib.rs
@@ -1,2 +1,10 @@
+
+#[macro_use]
+extern crate diesel;
+extern crate dotenv;
+extern crate serde;
+extern crate serde_json;
+
 pub mod core;
-pub mod model;
\ No newline at end of file
+pub mod model;
+pub mod schema;
diff --git a/workspace/web_edu/web_edu_lib/src/model.rs b/workspace/web_edu/web_edu_lib/src/model.rs
index 4164b84..0edafc0 100644
--- a/workspace/web_edu/web_edu_lib/src/model.rs
+++ b/workspace/web_edu/web_edu_lib/src/model.rs
@@ -1,105 +1,107 @@
-pub mod models {
+pub mod model {
 
-    pub use::(crate) web_edu_model_product_variant;
-    pub use::(crate) web_edu_model_variant;
+    // use self::{model_variant::NewVariant, model_product::NewProduct};
     
-    /// We might need additional models that have a different purpose and that aren’t connected to a table for our business logic.
-    #[derive(Clone)]
-    pub struct NewVariantValue {
-        pub variant: NewVariant,
-        pub values: Vec<Option<String>>
-    }
-
-    pub struct NewCompleteProduct {
-        pub product: NewProduct,
-        pub variants: Vec<NewVariantValue>
-    }
+    // /// We might need additional models that have a different purpose and that aren’t connected to a table for our business logic.
+    // #[derive(Clone)]
+    // pub struct NewVariantValue {
+    //     pub variant: NewVariant,
+    //     pub values: Vec<Option<String>>
+    // }
+
+    // pub struct NewCompleteProduct {
+    //     pub product: NewProduct,
+    //     pub variants: Vec<NewVariantValue>
+    // }
 
     // ----------------------------database models-------------
 
-    pub mod web_edu_model_product {
+pub mod model_product {
         use diesel::Insertable;
-        use web_edu::schema::*;
+        use crate::schema::*;
         //
         use serde::{Serialize, Deserialize};
         use diesel::Queryable;
 
-        /// This struct will be our model for inserting data in our database. 
-        /// Therefore, we need it to be Insertable, We also need to give it the name of our table.
-        /// We’re now prepared to add the code corresponding to creating a products table.
+
         #[derive(Insertable, Debug)]
         #[table_name="products"]
         pub struct NewProduct {
             pub name: String,
             pub cost: f64,
             pub active: bool,
         }
-
+        // This struct will be our model for inserting data in our database. 
+        // Therefore, we need it to be Insertable, We also need to give it the name of our table.
+        // We’re now prepared to add the code corresponding to creating a products table.
         #[derive(Queryable, Debug, Serialize, Deserialize)]
         pub struct Product {
             pub id: i32,
             pub name: String,
             pub cost: f64,
             pub active: bool,
         }
-    }
-    pub mod web_edu_model_variant {
-        use diesel::{ Insertable, Identifiable, Queryable};
-        use serde::{Serialize, Deserialize};
-        use shoe_store::schema::variants;
+}
 
-        #[derive(Identifiable, Queryable, Debug, Serialize, Deserialize)]
-        #[table_name = "variants"]
-        pub struct Variant {
-            pub id: i32,
-            pub name: String,
-        }
+// pub mod model_variant {
+//         use diesel::{ Insertable, Identifiable, Queryable};
+//         use serde::{Serialize, Deserialize};
+//         use crate::schema::variants;
 
-        #[derive(Insertable, Debug, Clone)]
-        #[table_name="variants"]
-        pub struct NewVariant {
-            pub name: String,
-        }
-    }
-    pub mod web_edu_model_product_variant {
-        use web_edu::schema::products_variants;
+//         #[derive(Identifiable, Queryable, Debug, Serialize, Deserialize)]
+//         #[table_name = "variants"]
+//         pub struct Variant {
+//             pub id: i32,
+//             pub name: String,
+//         }
 
-        #[derive(Insertable, Debug)]
-        #[table_name="products_variants"]
-        pub struct NewProductVariant {
-            pub product_id: i32,
-            pub variant_id: i32,
-            pub value: Option<String>
-        }
-    }
-
-    pub mod web_edu_model_product_edit {
-        #[derive(Insertable, Queryable, AsChangeset, Debug, Clone, Serialize, Deserialize)]
-        #[table_name="variants"]
-        pub struct FormVariant {
-            pub id: Option<i32>,
-            pub name: String
-        }
+//         #[derive(Insertable, Debug, Clone)]
+//         #[table_name="variants"]
+//         pub struct NewVariant {
+//             pub name: String,
+//         }
+//     }
+//     pub mod model_product_variant {
+//         use crate::schema::products_variants;
 
-        #[derive(Insertable, Debug, AsChangeset)]
-        #[table_name="products_variants"]
-        pub struct FormProductVariant {
-            pub id: Option<i32>,
-            pub variant_id: Option<i32>,
-            pub product_id: i32,
-            pub value: Option<String>
-        }
+//         #[derive(Insertable, Debug)]
+//         #[table_name="products_variants"]
+//         pub struct NewProductVariant {
+//             pub product_id: i32,
+//             pub variant_id: i32,
+//             pub value: Option<String>
+//         }
+//     }
 
-        pub struct FormProductVariantComplete {
-            pub variant: Option<FormVariant>,
-            pub product_variant: FormProductVariant,
-        }
+//     pub mod model_product_edit {
+//         use super::model_product::NewProduct;
 
-        pub struct FormProduct {
-            pub product: NewProduct,
-            pub variants: Vec<FormProductVariantComplete>
-        }
-    }
+//         #[derive(Insertable, Queryable, AsChangeset, Debug, Clone, Serialize, Deserialize)]
+//         #[table_name="variants"]
+//         pub struct FormVariant {
+//             pub id: Option<i32>,
+//             pub name: String
+//         }
+
+//         #[derive(Insertable, Debug, AsChangeset)]
+//         #[table_name="products_variants"]
+//         pub struct FormProductVariant {
+//             pub id: Option<i32>,
+//             pub variant_id: Option<i32>,
+//             pub product_id: i32,
+//             pub value: Option<String>
+//         }
+
+//         pub struct FormProductVariantComplete {
+//             pub variant: Option<FormVariant>,
+//             pub product_variant: FormProductVariant,
+//         }
+
+//         pub struct FormProduct {
+//             pub product: NewProduct,
+//             pub variants: Vec<FormProductVariantComplete>
+//         }
+//     }
 
 }
 
